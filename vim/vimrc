""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Configuration
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" No useless compatability with vi
set nocompatible

" Unicode
scriptencoding utf-8
set encoding=utf-8
set fileformat=unix

" Enable syntax highlighting
syntax on
" Required by vundle
filetype off

" Ruby community standard indentation
set autoindent
set expandtab
set shiftwidth=2
set softtabstop=2

" Show extra whitespace
set list listchars=tab:>-

" Show line numbers
set number

" History
set history=5000

" Persistent undo
set undofile
set undodir=~/.vim/undo
set undolevels=1000
set undoreload=10000

" Automatically re-read files
set autoread

" Enable file-type specific indenting
filetype indent on

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Key bindings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

nmap <F1> :tabnew<CR>
" F2 saves a file if necessary
nmap <F2> :update<CR>
vmap <F2> <Esc><F2>gv
imap <F2> <c-o><F2>
" F5 to insert current date
inoremap <F5> <C-R>=strftime("%F")<CR>
nnoremap <F4> :set invpaste paste?<CR>
set pastetoggle=<F4>
set showmode
" Toggle spell-check
map <leader>sc :setlocal spell! spelllang=en_us,is-hyph<CR>

" Remove trailing whitespace
nnoremap <Leader>rtw :%s/\s\+$//e<CR>

" Quick movements in insert mode
inoremap <leader>I <Esc>I
inoremap <leader>A <Esc>A
inoremap <leader>O <Esc>O

" Line modifications
inoremap <leader>C <Esc>C
inoremap <leader>S <Esc>S
inoremap <leader>D <Esc>dd
inoremap <leader>U <Esc>u

" Cross-out a box
map X :s/\[ \]/\[X\]/<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Commands
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Execute current file
nmap <F10> :!%:p<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugins
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'VundleVim/Vundle.vim'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Syntax/language
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Ruby
" :help Ruby
Plugin 'vim-ruby/vim-ruby'
" Scala
" :help scala
Plugin 'derekwyatt/vim-scala'
" Markdown
" :help vim-markdown
Plugin 'plasticboy/vim-markdown'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Sensible defaults
Plugin 'tpope/vim-sensible'

" File-type-specific templates
" :help skeleton
Plugin 'noahfrederick/vim-skeleton'

" Ultimate calendar application
" :help calendar
Plugin 'itchyny/calendar.vim'

" Commenting operations and styles
" :help NERDCommenter
Plugin 'scrooloose/nerdcommenter'

" Twitter client
" :help TwitVim
Plugin 'https://bitbucket.org/mortonfox/twitvim'

" ASCII drawing
" :help drawit
" <leader>di to start
" <leader>ds to leave
Plugin 'vim-scripts/DrawIt'

" Personal wiki for vim
" :help vimwiki
Plugin 'vimwiki/vimwiki'

" View man pages in vim
Plugin 'vim-utils/vim-man'

" Execute program with options.
" :help quickrun
Plugin 'thinca/vim-quickrun'

" Creating gists on http://gist.github.com
" :Help Gist
Plugin 'mattn/gist-vim'

" A simple vim plugin for quickly create and insert templates
" :VBTemplate [template]
" :VBEdit [template]
Plugin 'kabbamine/vbox.vim'

" Querying of the RFC database and loading RFC/STD documents into a Vim buffer
" :help RFC
Plugin 'mhinz/vim-rfc'

" Lean & mean status/tabline for vim that's light as air
" :help airline
Plugin 'vim-airline/vim-airline'

" Automatically open popup menu for completions when you enter characters or
" move the cursor in Insert mode
" :help acp
Plugin 'AutoComplPop'

" Shell reverse search emulation
Plugin 'goldfeld/ctrlr.vim'

" Syntastic syntax checking plugin
" :help syntastic
Plugin 'scrooloose/syntastic'

" tcomment provides easy to use, file-type sensible comments for Vim
" :help tcomment.txt
Plugin 'tomtom/tcomment_vim'

" Global Replace plugin 
Plugin 'vim-scripts/Greplace.vim'

" Ansible
Plugin 'pearofducks/ansible-vim'

" Color schemes
Plugin 'trevorrjohn/vim-obsidian'
Plugin 'petelewis/vim-evolution'
Plugin 'joshdick/onedark.vim'

call vundle#end()
filetype plugin indent on

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Misc
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Set color scheme
colorscheme evolution

" Highlight trailing whitespaces
match ErrorMsg '\s\+$'

" Leave insert mode on idle
au CursorHoldI * stopinsert
"au InsertEnter * let updaterestore=&updatetime | set updatetime=10000
"au InsertEnter * let &updatetime=updaterestore

"highlight Normal guibg=#32322f ctermbg=236
"highlight NonText guibg=#32322f ctermbg=236
highlight ColorColumn guibg=#000000 ctermbg=0
highlight Search ctermbg=cyan ctermfg=black
"let &colorcolumn=join(range(81,999),",")
"let &colorcolumn="80,".join(range(133,999),",")

" Add/change file extension in current buffer
" http://vim.wikia.com/wiki/Add/change_file_extension_in_current_buffer
command! -nargs=1 AddExt execute "saveas ".expand("%:p").<q-args>
command! -nargs=1 ChgExt execute "saveas ".expand("%:p:r").<q-args>

" Count word frequency
command! -range=% WordFrequency <line1>,<line2>call WordFrequency()
" Sort words
command! -nargs=0 -range SortWords call SortWords()

" Automatically create directories on save
function s:MkNonExDir(file, buf)
  if empty(getbufvar(a:buf, '&buftype')) && a:file!~#'\v^\w+\:\/'
    let dir=fnamemodify(a:file, ':h')
    if !isdirectory(dir)
      call mkdir(dir, 'p')
    endif
  endif
endfunction

augroup BWCCreateDir
  autocmd!
  autocmd BufWritePre * :call s:MkNonExDir(expand('<afile>'), +expand('<abuf>'))
augroup END

function! Min(number, ...)
  let result = a:number
  let index = a:0
  while index > 0
    let result = (a:{index} > result) ? result : a:{index}
    let index = index - 1
  endwhile
  return result
endf

" Sorts numbers in ascending order.
" Examples:
" [2, 3, 1, 11, 2] --> [1, 2, 2, 3, 11]
" ['2', '1', '10','-1'] --> [-1, 1, 2, 10]
function! Sorted(list)
  " Make sure the list consists of numbers (and not strings)
  " This also ensures that the original list is not modified
  let nrs = ToNrs(a:list)
  let sortedList = sort(nrs, "NaturalOrder")
  echo sortedList
  return sortedList
endfunction

" Comparator function for natural ordering of numbers
function! NaturalOrder(firstNr, secondNr)
  if a:firstNr < a:secondNr
    return -1
  elseif a:firstNr > a:secondNr
    return 1
  else 
    return 0
  endif
endfunction

" Coerces every element of a list to a number. Returns a new list without
" modifying the original list.
function! ToNrs(list)
  let nrs = []
  for elem in a:list
    let nr = 0 + elem
    call add(nrs, nr)
  endfor
  return nrs
endfunction

function! WordFrequency() range
  " Words are separated by whitespace or punctuation characters
  let wordSeparators = '[[:blank:][:punct:]]\+'
  let allWords = split(join(getline(a:firstline, a:lastline)), wordSeparators)
  let wordToCount = {}
  for word in allWords
    let wordToCount[word] = get(wordToCount, word, 0) + 1
  endfor

  let countToWords = {}
  for [word,cnt] in items(wordToCount)
    let words = get(countToWords,cnt,"")
    " Append this word to the other words that occur as many times in the text
    let countToWords[cnt] = words . " " . word
  endfor

  " Create a new buffer to show the results in
  new
  setlocal buftype=nofile bufhidden=hide noswapfile tabstop=20

  " List of word counts in ascending order
  let sortedWordCounts = Sorted(keys(countToWords))

  call append("$", "count \t words")
  call append("$", "--------------------------")
  " Show the most frequent words first -> Descending order
  for cnt in reverse(sortedWordCounts)
    let words = countToWords[cnt]
    call append("$", cnt . "\t" . words)
  endfor
endfunction

function! SortWords()
    " Get the visual mark points
    let StartPosition = getpos("'<")
    let EndPosition = getpos("'>")

    if StartPosition[0] != EndPosition[0]
        echoerr "Range spans multiple buffers"
    elseif StartPosition[1] != EndPosition[1]
        " This is a multiple line range, probably easiest to work line wise

        " This could be made a lot more complicated and sort the whole
        " lot, but that would require thoughts on how many
        " words/characters on each line, so that can be an exercise for
        " the reader!
        for LineNum in range(StartPosition[1], EndPosition[1])
            call setline(LineNum, join(sort(split(getline('.'), ' ')), " "))
        endfor
    else
        " Single line range, sort words
        let CurrentLine = getline(StartPosition[1])

        " Split the line into the prefix, the selected bit and the suffix

        " The start bit
        if StartPosition[2] > 1
            let StartOfLine = CurrentLine[:StartPosition[2]-2]
        else
            let StartOfLine = ""
        endif
        " The end bit
        if EndPosition[2] < len(CurrentLine)
            let EndOfLine = CurrentLine[EndPosition[2]:]
        else
            let EndOfLine = ""
        endif
        " The middle bit
        let BitToSort = CurrentLine[StartPosition[2]-1:EndPosition[2]-1]

        " Move spaces at the start of the section to variable StartOfLine
        while BitToSort[0] == ' '
            let BitToSort = BitToSort[1:]
            let StartOfLine .= ' '
        endwhile
        " Move spaces at the end of the section to variable EndOfLine
        while BitToSort[len(BitToSort)-1] == ' '
            let BitToSort = BitToSort[:len(BitToSort)-2]
            let EndOfLine = ' ' . EndOfLine
        endwhile

        " Sort the middle bit
        let Sorted = join(sort(split(BitToSort, ' ')), ' ')
        " Reform the line
        let NewLine = StartOfLine . Sorted . EndOfLine
        " Write it out
        call setline(StartPosition[1], NewLine)
    endif
endfunction
